# Проверка чётности числа
def is_even(n):
    return n % 2 == 0
'''
Алгоритм имеет константную сложность O(1), 
так как выполняет фиксированное количество операций, 
которое не зависит от размера входных данных.
'''

# Сортировка слиянием
def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        L = arr[:mid]
        R = arr[mid:]
        # Рекурсивная сортировка половин
        merge_sort(L)
        merge_sort(R)
        i = j = k = 0
        # Слияние отсортированных половин
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
        # Копирование оставшихся элементов
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1
    return arr
'''
Алгоритм делит массив на логарифмическое количество уровней 
(каждый раз деля пополам), то есть глубина рекурсии составляет O(log n). 
На каждом уровне выполняется слияние элементов за линейное время O(n). 
Таким образом, общая временная сложность составляет O(n log n).
'''

# Подсчет количества троек элементов в массиве, таких что
# сумма первых двух элементов равна третьему элементу.
def count_triplets(arr):
    n = len(arr)
    count = 0
    for i in range(n):
        for j in range(n):
            for k in range(n):
                if arr[i] + arr[j] == arr[k]:
                    count += 1
    return count
'''
Алгоритм перебирает все возможные комбинации троек,
используя три вложенных цикла, каждый из которых проходит 
по всему массиву длиной n. 
Общее количество итераций пропорционально n × n × n = n³. 
Поэтому временная сложность составляет O(n³).
'''

# Генерация перестановок в последовательности
def generate_permutations(sequence):
    if len(sequence) == 0:
        return [[]]
    permutations = []
    for i in range(len(sequence)):
        elem = sequence[i]
        rest = sequence[:i] + sequence[i+1:]
        for p in generate_permutations(rest):
            permutations.append([elem] + p)
    return permutations
'''
Функция рекурсивно генерирует все возможные перестановки элементов в последовательности.
Количество перестановок для n элементов равно n!.
Поэтому временная сложность составляет O(n!).
'''